'use strict';

var Q = require('q'),
    fs = require('fs'),
    path = require('path'),
    util = require('util'),
    merge = require('lodash.merge'),
    parser = require('./parser');

module.exports = loadTemplate;

/*
Templatizes the file and processes #include directives found within

@param  filePath  The full path to the file being loaded; required
@param  opts      Extra options, all of which are optional
{
    root: The root dir (for root-relative includes). Is assumed to be the process' current working directory if omitted.

    fileContents: If you already have the file's contents, pass it here as a Buffer or a string.  If this is omitted,
        the file's contents will be read from disk.  This is mostly an optimization for something like `gulp` where
        the file's contents have already been loaded (and potentially transformed)

    varDefaults:  Optional object with default values for template var substitutions.  If a substitution value is
        specified in both varDefaults and in the #include, the values from the #include will take precedence. For
        example, setting varDefaults to {'$foo':'bar'} is the equivalent of doing <!-- #include file="..." $foo="bar" -->

    varOverrides:  Optional object with override values for template substitutions.  If a substitution value is
        specified in both varOverrides and in the #include, the values from varOverrides will take precedence. For
        example, setting varOverrides to {'$foo':'bar'} is the equivalent of doing <!-- #include file="..." $foo="bar" -->
        If a value is set via varOverrides, it will be that value in the template and all sub-templates, no matter
        what value is specified.  This is a 20-ton sledgehammer that's useful in some scenarios.
}
@param cb         Optional.  If provided, operations are asynchronous instead of synchronous
 The root directory (for root-relative paths like "/path/to/file.html"); required
@param  contents  The file's contents.  If omitted, these will be read from disk.

#includes take this form:

  <!-- #include file="path/to/file.html" -->

Template file paths are required, and should be relative ("other-file.html", "../foo.html", or "nav/top.html") or
root-relative paths (like "/templ/head.html"). Relative paths are always relative to the current file (much like CSS),
while root-relative paths that start with a slash are resolved relative to the `rootDir` that you passed in.

Basic variable substitution is supported:

  <!-- #include file="path/to/file.html" token1="value1" token2="value2" -->

Any number of key/value tokens can be specified.   The loaded template file will have the substring "token1" replaced
with "value1", and "token2" replaced with "value2".  Token names can be 1 or more non-whitespace characters, other than
the equals sign. Quoted strings are parsed with JSON.parse, so you can slash-escape special characters like this:

  <!-- #include file="something.html" name="This has \"special\" chars\n...and multiple lines" -->

In this example, the replaced value for `name` will be

  This has "special" chars
  ...and multiple lines

Replacing a value in a template will also replace that value found in
sub-templates, so it's good to make your tokens specific and unique-ish, like this:

  <!-- #include file="header.html" ${page.title}="ACME Corporation" -->

Then in your file header.html, you can have something like this:

  <head>
    <title>${page.title}</title>
  </head>

*/
function loadTemplate(filePath, opts, cbLoaded)
{

    //opts is optional, so if it's a function, assume it's actually cb
    //and that opts was omitted
    if (typeof opts === 'function' && typeof cbLoaded === 'undefined')
    {
        cbLoaded = opts;
        opts = {};
    }
    //default values so we don't barf
    //TODO: lodash-merge 3.x mangles Buffers in Node v4+; should be fixed in lodash-merge v4.x
    //see https://github.com/lodash/lodash/issues/1453#issuecomment-139311305
    opts = merge({}, opts, function(a, b)
    {
        if (b instanceof Buffer)
        {
            return b;
        }
    }); //make a copy so we can change it
    opts.rootDir = path.resolve(opts.root || process.cwd());
    //save preloaded contents, but don't pass them down to child templates (so remove from opts)
    var preloadedFileContents = opts.fileContents || null;
    delete opts.fileContents;
    //resolve to an absolute path if it isn't already
    filePath = path.resolve(opts.rootDir, filePath);

    //time to load and process the file
    var resultPromise = loadFileContents(filePath, preloadedFileContents).then(function (fileContents)
    {
        var chunks = parser.parse(fileContents, filePath);
        var currentDir = path.dirname(filePath);
        //we need to asynchronously load and process all sub-components
        return Q.all(chunks.map(function (chunk)
        {
            //easy case to process
            if (typeof chunk === 'string')
            {
                //if Q.all gets a non-promise, it'll pass it through when other promises resolve
                return chunk;
            }
            //it's an include, handle it here
            else if (chunk.type === 'include')
            {
                //resolve relative to the correct path
                var isAbsolute = (chunk.file.substring(0, 1) === '/');
                var relativeDir = (isAbsolute ? opts.rootDir : currentDir);
                var includePath = path.join(relativeDir, chunk.file);
                //load and templatize the sub-file;
                return loadTemplate(includePath, opts).then(function (rawIncludeText)
                {
                    var mergedVars = merge({}, opts.varDefaults || {}, chunk.vars || {}, opts.varOverrides || {});
                    return substituteVars(rawIncludeText, mergedVars);
                }).catch(function (caughtException)
                {
                    //provide a nicer error for file-not-found
                    if (caughtException.code === 'ENOENT')
                    {
                        var msg = util.format('Included file %j does not exist (%j:%d)', includePath, filePath, chunk.line);
                        var err = new Error(msg, includePath, chunk.line);
                        err.original = caughtException;
                        throw err;
                    }
                    else
                    {
                        throw caughtException;
                    }
                });
            }
            //unknown, bail
            else
            {
                throw new Error('Unknown chunk type: ' + chunk.type);
            }
        })).then(function (pieces)
        {
            //once all chunks are loaded and reduced to strings, the promise will contain
            //an array of strings.  So we just weld them together and we're done here
            return pieces.join('');
        });

    });
    //interface with external oldstyle callback, if provided
    if (typeof cbLoaded === 'function')
    {
        resultPromise.then(function (result)
        {
            setImmediate(cbLoaded, null, result);
        });
        resultPromise.catch(function (err)
        {
            if (typeof cbLoaded === 'function')
            {
                setImmediate(cbLoaded, err);
            }
            throw err;
        });
    }
    //also return the promise containing the result
    //(we also need this for internal recursion purposes)
    return resultPromise;
}

//helper to construct a promise resolved with a specific value
function promiseValue(value)
{
    return Q.fcall(function ()
    {
        return value;
    });
}

//helper function to load file; returns promise that's resolved with contents
function loadFileContents(filePath, preloaded)
{
    //use pre-supplied contents?
    if (typeof preloaded !== 'undefined' && preloaded !== null)
    {
        //return a promise which will get resolved with the preloaded value
        if (preloaded instanceof Buffer)
        {
            return promiseValue(preloaded.toString());
        }
        else
        {
            return promiseValue(String(preloaded));
        }
    }
    else
    {
        return Q.nfcall(fs.readFile, filePath).invoke('toString');
    }
}

/*
Substitutes the chunk variables
*/
function substituteVars(rawText, vars)
{
    if (!vars)
    {
        return rawText;
    }
    //after loading contents, perform variable substitution
    Object.keys(vars).forEach(function (varName)
    {
        if (vars.hasOwnProperty(varName))
        {
            var varValue = vars[varName];
            rawText = replaceAll(rawText, varName, varValue);
        }
    });
    return rawText;
}

/*
Replaces all instances of `find` in `str` with `replace`
Optionally case-insensitive.  Uses regex hax to make this all work
*/
function replaceAll(str, find, replace, caseInsensitive)
{
    if (find === null || find === (void 0))
    {
        return str;
    }
    if (replace === null || replace === (void 0))
    {
        replace = '';
    }
    find = String(find);
    replace = String(replace).replace(/\$/g, '$$$$'); //$ has special meaning in RHS of regexes, escape with $$
    var findRegex = new RegExp(find.replace(/([\\\^\$\{\}\[\]\(\)\.\*\+\?\|])/g, '\\$&'), caseInsensitive ? 'gi' : 'g');
    return str.replace(findRegex, replace);
}
