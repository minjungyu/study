'use strict';
/* global it: false, describe: false */

var fs = require('fs'),
    path = require('path'),
    merge = require('lodash.merge'),
    should = require('should'),
    poundInclude = require('../src/index');

describe('templater', function ()
{
    /*
    @param config {
        filePath: The file to be loaded
        options: An options hash to pass to poundInclude as second arg
        expectValue: Expect a successful call that returns this value
        expectThrow: Expect an exception matching this regex to be thrown
    }
    @param cb The Mocha callback fn (invoke with no args = success, invoke with arg-error = failure)
    */
    function asyncTest(config, cb)
    {
        try
        {
            poundInclude(config.filePath, config.options, function (err, result)
            {
                //unexpected problem; abort
                if (err && !config.expectThrow)
                {
                    return cb(err);
                }
                //attempt to vet; pass assertion failures to the callback
                try
                {
                    //expecting success
                    if (config.expectThrow)
                    {
                        should(err).not.equal(null);
                        should(function ()
                        {
                            throw err;
                        }).throw(config.expectThrow);
                    }
                    else
                    {
                        should(result).equal(config.expectValue);
                    }
                    //if we get here, we were successful
                    cb();
                }
                catch (ex)
                {
                    cb(ex);
                }
            });
        }
        catch (ex)
        {
            cb(ex); //fail
        }
    }

    itL('templates/no-includes', 'should load an empty file, empty.html', function (root, cb)
    {
        asyncTest({
            filePath: path.join(root, 'empty.html'),
            options: {
                root: root
            },
            expectValue: ''
        }, cb);
    });

    itL('templates/no-includes', 'should load an empty file, empty.html, without using an options hash', function (root, cb)
    {
        asyncTest({
            filePath: path.join(root, 'empty.html'),
            expectValue: ''
        }, cb);
    });

    itL('templates/no-includes', 'should accept file contents when provided as a string', function (root, cb)
    {
        var contents = 'sample file contents';
        asyncTest({
            filePath: path.join(root, 'empty.html'),
            options: {
                root: root,
                fileContents: contents
            },
            expectValue: contents
        }, cb);
    });

    itL('templates/no-includes', 'should accept file contents when provided as a Buffer', function (root, cb)
    {
        var contents = 'sample buffer file contents';
        asyncTest({
            filePath: path.join(root, 'empty.html'),
            options: {
                root: root,
                fileContents: new Buffer(contents)
            },
            expectValue: contents
        }, cb);
    });

    itL('templates/no-includes', 'should load a non-empty file with no #includes', function (root, cb)
    {
        asyncTest({
            filePath: path.join(root, 'non-empty.html'),
            options: {root: root},
            expectValue: '<body>\nSample input\n</body>\n'
        }, cb);
    });

    //and now for a lot of tests which load stuff and compare to stored expected output on disk

    itL('templates/simple/one-include', 'should load a simple file with a single #include', loadAndCompareExpected);
    itL('templates/simple/many-includes', 'should load a simple file with more than one #include', loadAndCompareExpected);
    itL('templates/simple/chained/short', 'should load a simple file with a short chain of #includes', loadAndCompareExpected);
    itL('templates/simple/chained/long', 'should load a simple file with a long chain of #includes', loadAndCompareExpected);
    itL('templates/path-relative/to-child', 'should load an #include from a subfolder', loadAndCompareExpected);
    itL('templates/path-relative/to-parent', 'should load an #include from the parent folder', loadAndCompareExpected);
    itL('templates/path-absolute/simple', 'should load an #include a root-relative path', loadAndCompareExpected);
    itL('templates/path-absolute/chained', 'should load an #include a root-relative path, including following chains', loadAndCompareExpected);
    itL('templates/substitution/1var1inst', 'should substitute variables (1 var, 1 instance)', loadAndCompareExpected);
    itL('templates/substitution/1var4inst', 'should substitute variables (1 var, replaced 4 times)', loadAndCompareExpected);
    itL('templates/substitution/var-missing', 'should substitute variables (unchanged if var not specified)', loadAndCompareExpected);
    itL('templates/substitution/var-defaults', 'should substitute variables (using values from varDefaults if not provided)', loadAndCompareExpected, {
        varDefaults: {
            '$var1': 'defaultVar1',
            '$var2': 'defaultVar2'
        }
    });
    itL('templates/substitution/var-overrides', 'should substitute variables (using values from varOverrides even if provided)', loadAndCompareExpected, {
        varOverrides: {
            '$var1': 'overrideVar1',
            '$var2': 'overrideVar2'
        }
    });

    //test some error conditions

    itL('templates/missing-file', 'should throw exception if the relative-path included file does not exist', function (root, cb)
    {
        var ex = /^Included file ".+\/missing-file\/missing-file.html" does not exist \(".+\/missing-file\/relative.html":5\)/i;
        asyncTest({
            filePath: path.join(root, 'relative.html'),
            options: {root: root},
            expectThrow: ex
        }, cb);
    });
    itL('templates/missing-file', 'should throw exception if the absolute-path included file does not exist', function (root, cb)
    {
        var ex = /^Included file ".+\/missing-file\/missing-file.html" does not exist \(".+\/missing-file\/absolute.html":5\)/i;
        asyncTest({
            filePath: path.join(root, 'absolute.html'),
            options: {root: root},
            expectThrow: ex
        }, cb);
    });

    /*
    Helper method to make most of the input/output methods extremely terse
    Given a template root directory, this will use the templater to load root/in.html,
    and then assert that the result should equal the expected markup stored in root/out.html
    Takes in optional options object that gets passed through to lb-include
    */
    function loadAndCompareExpected(root, cb, opts)
    {
        opts = merge({root:root}, opts||{});
        var inPath = path.join(root, 'in.html');
        var outPath = path.join(root, 'out.html');
        fs.readFile(outPath, function (err, expectedContents)
        {
            expectedContents = expectedContents.toString(); //buffer to string
            asyncTest({
                filePath: inPath,
                options: opts,
                expectValue: expectedContents
            }, cb);
        });
    }
});

/*
helper method for providing a test case but first building the root directory, which
will get passed as first argument to func() when executed.  This is basically some nice semantic sugar.
*/
function itL(rootDir, name, func, opts)
{

    return it('(in ' + rootDir + ') ' + name, function (cb)
    {
        var root = path.join(__dirname, rootDir);
        try
        {
            fs.stat(root, function (err, stats)
            {
                if (err)
                {
                    return cb(err);
                }
                try
                {
                    if (stats.isDirectory())
                    {
                        return func(root, cb, opts);
                    }
                    else
                    {
                        throw new Error('Test template root directory not found or is not a directory');
                    }
                }
                catch (ex)
                {
                    return cb(ex);
                }
            });
        }
        catch (ex)
        {
            return cb(ex);
        }
    });
}
