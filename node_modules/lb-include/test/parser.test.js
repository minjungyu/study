'use strict';
/* global it: false, describe: false */

var should = require('should');
var parser = require('../src/parser');

describe('parser.makeError()', function ()
{
    it('should build the correct message', function ()
    {
        parser.makeError('error-message', 'file.html', 5)
            .message.should.equal('error-message (file.html:5)');
    });
    it('should handle a missing message', function ()
    {
        parser.makeError(null, 'file.html', 5)
            .message.should.equal('Unknown error (file.html:5)');
    });
});

describe('parser.parse()', function ()
{
    //helper function for constructing expected include results
    function $include(file, line, vars)
    {
        return {
            type: 'include',
            file: file,
            line: line,
            vars: vars || {}
        };
    }

    //helper method for attempting to parse something, and expecting an error to be thrown
    function parseExpectThrow(opts)
    {
        should(function ()
        {
            parser.parse(opts.text, opts.file || 'test.html');
        }).throw(opts.throws);
    }

    /***
     * Positive tests (we don't expect to throw an error)
     **/

    it('should parse empty string', function ()
    {
        parser.parse('').should.eql([]);
    });

    it('should parse simple strings', function ()
    {
        parser.parse('hello').should.eql(['hello']);
        parser.parse('hello\nworld').should.eql(['hello\nworld']);
        parser.parse('hello <!-- world -->').should.eql(['hello <!-- world -->']);
    });

    it('should parse a single #include', function ()
    {
        var text = '<!-- #include file="file.html" -->';
        parser.parse(text).should.eql([
            $include('file.html', 1, {})
        ]);
    });

    it('should not depend upon whitespace in the #include', function ()
    {
        var expected = [$include('file.html', 1, {})];
        parser.parse('<!-- #include file="file.html" -->').should.eql(expected);
        parser.parse('<!--  #include file="file.html" -->').should.eql(expected);
        parser.parse('<!--#include file="file.html"-->').should.eql(expected);
        parser.parse('<!--\n\t#include file="file.html"\n    -->').should.eql(expected);
    });

    it('should identify the line on which the #include started', function ()
    {
        for (var i = 1; i <= 10; i++)
        {
            testWithNewlinesPrefixed(i);
        }

        function testWithNewlinesPrefixed(linesBefore)
        {
            var newlines = new Array(linesBefore + 1).join('\n');
            var text = newlines + '<!-- #include file="file.html" -->';
            parser.parse(text).should.eql([
                    newlines,
                    $include('file.html', linesBefore + 1, {})]
            );
        }
    });

    it('should parse an #include with a single character before', function ()
    {
        var text = 'Q<!-- #include file="file.html" -->';
        parser.parse(text).should.eql([
            'Q',
            $include('file.html', 1, {})
        ]);
    });

    it('should parse an #include with a single character after', function ()
    {
        var text = '<!-- #include file="file.html" -->Q';
        parser.parse(text).should.eql([
            $include('file.html', 1, {}),
            'Q'
        ]);
    });

    it('should parse an #include with text before', function ()
    {
        var text = 'Hello, <!-- #include file="file.html" -->';
        parser.parse(text).should.eql([
            'Hello, ',
            $include('file.html', 1, {})
        ]);
    });

    it('should parse an #include with text after', function ()
    {
        var text = '<!-- #include file="file.html" --> rocks!';
        parser.parse(text).should.eql([
            $include('file.html', 1, {}),
            ' rocks!'
        ]);
    });

    it('should parse an #include with text before and after', function ()
    {
        var text = 'Hello, <!-- #include file="file.html" --> rocks!';
        parser.parse(text).should.eql([
            'Hello, ',
            $include('file.html', 1, {}),
            ' rocks!'
        ]);
    });

    it('should parse multiple #includes', function ()
    {
        var text = '<!-- #include file="file1.html" --><!-- #include file="file2.html" -->';
        parser.parse(text).should.eql([
            $include('file1.html', 1, {}),
            $include('file2.html', 1, {})
        ]);
    });

    it('should parse multiple #includes with space between', function ()
    {
        var text = '<!-- #include file="file1.html" -->\n<!-- #include file="file2.html" -->';
        parser.parse(text).should.eql([
            $include('file1.html', 1, {}),
            '\n',
            $include('file2.html', 2, {})
        ]);
    });

    it('should parse a single valueless property', function ()
    {
        parser.parse('<!-- #include file="file.html" prop1 -->').should.eql([
            $include('file.html', 1, {prop1: true})
        ]);
    });

    it('should parse multiple valueless properties', function ()
    {
        parser.parse('<!-- #include file="file.html" prop1 prop2 -->').should.eql([
            $include('file.html', 1, {prop1: true, prop2: true})
        ]);
    });

    it('should parse a single unquoted property', function ()
    {
        parser.parse('<!-- #include file="file.html" prop1=val1 -->').should.eql([
            $include('file.html', 1, {prop1: 'val1'})
        ]);
    });

    it('should parse a single empty unquoted property', function ()
    {
        parser.parse('<!-- #include file="file.html" prop1= -->').should.eql([
            $include('file.html', 1, {prop1: ''})
        ]);
    });

    it('should parse multiple unquoted properties', function ()
    {
        parser.parse('<!-- #include file="file.html" prop1=val1 prop2=val2 -->').should.eql([
            $include('file.html', 1, {prop1: 'val1', prop2: 'val2'})
        ]);
    });

    it('should parse a single quoted property', function ()
    {
        parser.parse('<!-- #include file="file.html" prop1="val1" -->').should.eql([
            $include('file.html', 1, {prop1: 'val1'})
        ]);
    });

    it('should parse a single empty quoted property', function ()
    {
        parser.parse('<!-- #include file="file.html" prop1="" -->').should.eql([
            $include('file.html', 1, {prop1: ''})
        ]);
    });

    it('should parse multiple quoted properties', function ()
    {
        parser.parse('<!-- #include file="file.html" prop1="val1" prop2="val2" -->').should.eql([
            $include('file.html', 1, {prop1: 'val1', prop2: 'val2'})
        ]);
    });

    it('should parse a single quoted property with a strange name', function ()
    {
        parser.parse('<!-- #include file="file.html" ${_@^@_}$="strange" -->').should.eql([
            $include('file.html', 1, {'${_@^@_}$': 'strange'})
        ]);
    });

    it('should parse a single quoted property with escaped quotes', function ()
    {
        parser.parse('<!-- #include file="file.html" prop1="this \\"special\\" value" -->').should.eql([
            $include('file.html', 1, {prop1: 'this "special" value'})
        ]);
    });

    it('should parse a single quoted property with escaped newlines', function ()
    {
        parser.parse('<!-- #include file="file.html" prop1="this\\nvalue" -->').should.eql([
            $include('file.html', 1, {prop1: 'this\nvalue'})
        ]);
    });

    it('should parse a single quoted property with escaped tabs', function ()
    {
        parser.parse('<!-- #include file="file.html" prop1="this\\tvalue" -->').should.eql([
            $include('file.html', 1, {prop1: 'this\tvalue'})
        ]);
    });

    it('should parse a single quoted property with escaped backslashes', function ()
    {
        parser.parse('<!-- #include file="file.html" prop1="this \\\\ value" -->').should.eql([
            $include('file.html', 1, {prop1: 'this \\ value'})
        ]);
    });

    it('should parse a mixture of properties that are quote/unquoted', function ()
    {
        parser.parse('<!-- #include file="file.html" prop1 prop2=val2 prop3="val3" prop4 -->').should.eql([
            $include('file.html', 1, {prop1: true, prop2: 'val2', prop3: 'val3', prop4: true})
        ]);
    });

    it('should parse a mixture of properties that are quote/unquoted on multiple lines', function ()
    {
        parser.parse('<!-- #include file="file.html"\n\tprop1\n\tprop2=val2\n\tprop3="val3"\n\tprop4\n-->').should.eql([
            $include('file.html', 1, {prop1: true, prop2: 'val2', prop3: 'val3', prop4: true})
        ]);
    });

    /***
     * Negative tests (conditions under which we do expect to throw an error)
     **/

    it('should throw an exception if the file attribute is missing', function ()
    {
        parseExpectThrow({
            text: '<!-- #include -->',
            throws: 'Missing file= attribute in #include (test.html:1)'
        });
    });

    it('should throw an exception if the #include is not closed', function ()
    {
        parseExpectThrow({
            text: '<!-- #include',
            throws: 'Unexpected end of input (attr name) (test.html:1)'
        });
    });

    it('should throw an exception if the #include is not closed, regardless of which line', function ()
    {
        parseExpectThrow({
            text: '\n<!--\n#include',
            throws: 'Unexpected end of input (attr name) (test.html:3)'
        });
    });

    it('should throw an exception if the attribute name never terminates', function ()
    {
        parseExpectThrow({
            text: '<!-- #include file',
            throws: 'Unexpected end of input (in attr name) (test.html:1)'
        });
    });

    it('should throw an exception if the attribute name never terminates, regardless of which line', function ()
    {
        parseExpectThrow({
            text: '\n<!--\n#include\nfile',
            throws: 'Unexpected end of input (in attr name) (test.html:4)'
        });
    });

    it('should throw an exception if the unquoted property never terminates', function ()
    {
        parseExpectThrow({
            text: '<!-- #include file=foo.html',
            throws: 'Unexpected end of input (unquoted value) (test.html:1)'
        });
    });

    it('should throw an exception if the unquoted property never terminates, regardless of line', function ()
    {
        parseExpectThrow({
            text: '\n<!--\n#include\nfile=foo.html',
            throws: 'Unexpected end of input (unquoted value) (test.html:4)'
        });
    });

    it('should throw an exception if the quoted property is not closed', function ()
    {
        parseExpectThrow({
            text: '<!-- #include file="this is never closed',
            throws: 'Unexpected end of input (unterminated quoted value) (test.html:1)'
        });
    });

    it('should throw an exception if the quoted property is not closed, regardless of which line', function ()
    {
        parseExpectThrow({
            text: '<!-- #include file="this is never closed',
            throws: 'Unexpected end of input (unterminated quoted value) (test.html:1)'
        });
    });

});
